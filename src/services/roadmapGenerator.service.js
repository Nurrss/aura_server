// roadmapGenerator.service.js
import dayjs from 'dayjs';
import { prisma } from '../config/prismaClient.js';
import { createGoal } from './goal.service.js';
import { createMilestone } from './milestone.service.js';

/**
 * Generate milestones for a goal using rule-based logic
 * @param {Object} goal - Goal object
 * @param {Object} options - Generation options
 * @returns {Promise<Array>} - Created milestones
 */
export const generateMilestonesForGoal = async (goal, options = {}) => {
  const { milestonesPerYear = 4, startDate } = options;

  const milestones = [];
  const start = dayjs(startDate || new Date());
  const targetYear = goal.targetYear;

  // Generate quarterly milestones
  const numMilestones = milestonesPerYear * targetYear;
  const monthsPerMilestone = 12 / milestonesPerYear;

  for (let i = 0; i < numMilestones; i++) {
    const dueDate = start.add(i * monthsPerMilestone, 'month');
    const year = Math.floor(i / milestonesPerYear) + 1;
    const quarter = (i % milestonesPerYear) + 1;

    const milestone = await createMilestone(goal.id, {
      title: `${goal.title} - Q${quarter} Year ${year}`,
      description: `Quarterly milestone for ${goal.title}`,
      dueDate: dueDate.toDate(),
      period: `Q${quarter}`,
      year,
      quarter,
      order: i,
      isAutoGenerated: true,
    });

    milestones.push(milestone);
  }

  return milestones;
};

/**
 * Validate roadmap time feasibility
 * @param {Array} goals - Array of goals with estimated hours
 * @param {number} weeklyAvailableHours - User's available hours per week
 * @returns {Object} - Validation result
 */
export const validateTimeFeasibility = (goals, weeklyAvailableHours) => {
  const totalWeeklyHours = goals.reduce((sum, goal) => sum + (goal.estimatedWeeklyHours || 0), 0);

  const bufferFactor = 0.8; // Use only 80% of available time
  const maxRecommendedHours = weeklyAvailableHours * bufferFactor;

  return {
    isValid: totalWeeklyHours <= maxRecommendedHours,
    totalWeeklyHours,
    availableHours: weeklyAvailableHours,
    maxRecommendedHours,
    overloadPercentage: totalWeeklyHours > maxRecommendedHours
      ? ((totalWeeklyHours / maxRecommendedHours - 1) * 100).toFixed(1)
      : 0,
    recommendation: totalWeeklyHours > maxRecommendedHours
      ? `Reduce total time commitment by ${(totalWeeklyHours - maxRecommendedHours).toFixed(1)} hours/week`
      : 'Time allocation looks good',
  };
};

/**
 * Calculate priority score for goal prioritization
 * @param {Object} goal - Goal object with importance and urgency
 * @returns {number} - Priority score (0-10)
 */
export const calculatePriorityScore = (goal) => {
  const importanceFactor = (goal.importance || 3) / 5; // Normalize to 0-1
  const urgencyFactor = goal.targetYear === 1 ? 1 : (6 - goal.targetYear) / 5;
  const dependencyFactor = (goal.dependencies?.length || 0) > 0 ? 1.2 : 1;

  const score = (importanceFactor * 0.4 + urgencyFactor * 0.6) * dependencyFactor * 10;

  return Math.min(score, 10);
};

/**
 * Detect dependency conflicts
 * @param {Array} goals - Array of goals with dependencies
 * @returns {Array} - Array of conflicts
 */
export const detectDependencyConflicts = (goals) => {
  const conflicts = [];

  goals.forEach((goal) => {
    if (!goal.dependencies || goal.dependencies.length === 0) return;

    goal.dependencies.forEach((depId) => {
      const dependency = goals.find((g) => g.id === depId);

      if (!dependency) {
        conflicts.push({
          goalId: goal.id,
          goalTitle: goal.title,
          type: 'missing_dependency',
          message: `Depends on goal ${depId} which doesn't exist`,
        });
      } else if (dependency.targetYear > goal.targetYear) {
        conflicts.push({
          goalId: goal.id,
          goalTitle: goal.title,
          type: 'timeline_conflict',
          message: `Depends on "${dependency.title}" (Year ${dependency.targetYear}) but is scheduled for Year ${goal.targetYear}`,
        });
      }
    });

    // Check for circular dependencies (simple check)
    goal.dependencies.forEach((depId) => {
      const dependency = goals.find((g) => g.id === depId);
      if (dependency?.dependencies?.includes(goal.id)) {
        conflicts.push({
          goalId: goal.id,
          goalTitle: goal.title,
          type: 'circular_dependency',
          message: `Circular dependency detected with "${dependency.title}"`,
        });
      }
    });
  });

  return conflicts;
};

/**
 * Balance goals across categories
 * @param {Array} goals - Array of goals
 * @param {number} totalHours - Total available hours
 * @returns {Object} - Category distribution analysis
 */
export const analyzeGoalBalance = (goals, totalHours) => {
  const distribution = {};
  const hoursByCategory = {};

  goals.forEach((goal) => {
    if (!distribution[goal.category]) {
      distribution[goal.category] = 0;
      hoursByCategory[goal.category] = 0;
    }
    distribution[goal.category]++;
    hoursByCategory[goal.category] += goal.estimatedWeeklyHours || 0;
  });

  const categories = Object.keys(distribution);
  const percentageByCategory = {};

  categories.forEach((cat) => {
    percentageByCategory[cat] = ((hoursByCategory[cat] / totalHours) * 100).toFixed(1);
  });

  const maxCategory = categories.reduce((max, cat) => {
    return hoursByCategory[cat] > hoursByCategory[max] ? cat : max;
  }, categories[0]);

  const isBalanced = hoursByCategory[maxCategory] / totalHours <= 0.6;

  return {
    distribution,
    hoursByCategory,
    percentageByCategory,
    isBalanced,
    recommendation: !isBalanced
      ? `Category "${maxCategory}" takes ${percentageByCategory[maxCategory]}% of time (max recommended: 60%)`
      : 'Goals are well-balanced across categories',
  };
};

/**
 * Generate a structured roadmap from user input
 * @param {number} userId - User ID
 * @param {Object} roadmapData - Roadmap creation data
 * @param {Array} goalsData - Array of goal objects
 * @returns {Promise<Object>} - Created roadmap with goals
 */
export const generateRoadmap = async (userId, roadmapData, goalsData) => {
  const { title, visionStatement, startDate, weeklyAvailableHours = 20 } = roadmapData;

  // Validate time feasibility
  const validation = validateTimeFeasibility(goalsData, weeklyAvailableHours);
  if (!validation.isValid) {
    throw new Error(`Time overload: ${validation.recommendation}`);
  }

  // Check for dependency conflicts
  const conflicts = detectDependencyConflicts(goalsData);
  if (conflicts.length > 0) {
    throw new Error(`Dependency conflicts found: ${conflicts.map((c) => c.message).join('; ')}`);
  }

  // Create roadmap
  const start = dayjs(startDate || new Date());
  const roadmap = await prisma.roadmap.create({
    data: {
      userId,
      title,
      visionStatement,
      startDate: start.toDate(),
      endDate: start.add(5, 'year').toDate(),
      status: 'draft',
      generationMethod: 'manual',
      progressPercentage: 0,
    },
  });

  // Create goals with calculated priorities
  const goalsWithPriority = goalsData.map((g) => ({
    ...g,
    priority: calculatePriorityScore(g),
  }));

  // Sort by priority
  goalsWithPriority.sort((a, b) => b.priority - a.priority);

  const createdGoals = [];
  for (let i = 0; i < goalsWithPriority.length; i++) {
    const goalData = goalsWithPriority[i];
    const goal = await createGoal(roadmap.id, {
      ...goalData,
      order: i,
    });
    createdGoals.push(goal);
  }

  return {
    roadmap,
    goals: createdGoals,
    validation,
  };
};

export default {
  generateMilestonesForGoal,
  validateTimeFeasibility,
  calculatePriorityScore,
  detectDependencyConflicts,
  analyzeGoalBalance,
  generateRoadmap,
};
